package edu.depauw.scales

import utest._

import scala.meta._

object UtilsTests extends TestSuite {
  val tests = Tests {
    def runTest(src: String, expected: String) = {
      val stree = src.parse[Source].get
      val dtree = Utils.desugar(stree)
      val found = dtree.syntax.replaceAll("\\s+", " ")
      val expect = expected.replaceAll("\\s+", " ")
      assert(expect == found)
    }

    test("binary operator") {
      runTest("object a { val b = c + d * e }",
              "object a { val b = c.+(d.*(e)) }")
    }

    test("right-associative binary operator") {
      runTest("object a { val b = c :: d :: e }",
              "object a { val b = e.::(d).::(c) }")
    }

    test("unary operator") {
      runTest("object a { val b = + c + d + }",
              "object a { val b = c.unary_+().+(d).+ }")
    }

    test("string interpolation") {
      runTest("object a { val b = s\"hello $c world ${d+e}!\" }",
              "object a { val b = new StringContext(\"hello \", \" world \", \"!\").s(c, d.+(e)) }")
    }

    test("for comprehension") {
      runTest("object a { val b = for (c <- d) yield e }",
              """object a { val b = d.map(new { this =>
                |  def apply(fresh$1) = fresh$1 match { case c => e }
                |  def isDefinedAt(fresh$1) = fresh$1 match { case c => true case _ => false }
                |}) }""".stripMargin)
      runTest("object a { val b = for (c <- d; e <- f) yield (c * e) }",
              """object a { val b = d.flatMap(new { this =>
                |  def apply(fresh$2) = fresh$2 match { case c => f.map(new { this =>
                |    def apply(fresh$3) = fresh$3 match { case e => c.*(e) }
                |    def isDefinedAt(fresh$3) = fresh$3 match { case e => true case _ => false } }) }
                |  def isDefinedAt(fresh$2) = fresh$2 match { case c => true case _ => false } 
                |}) }""".stripMargin)
      runTest("object a { val b = for (c <- d + e; f <- g * h) yield (c % f) }",
              """object a { val b = d.+(e).flatMap(new { this =>
                |  def apply(fresh$4) = fresh$4 match { case c => g.*(h).map(new { this =>
                |    def apply(fresh$5) = fresh$5 match { case f => c.%(f) }
                |    def isDefinedAt(fresh$5) = fresh$5 match { case f => true case _ => false } }) }
                |  def isDefinedAt(fresh$4) = fresh$4 match { case c => true case _ => false }
                |}) }""".stripMargin)
    }

    test("for comprehension guard") {
      runTest("object a { val b = for (c <- d; if e) yield f }",
              """object a { val b = d.withFilter(new { this =>
                |  def apply(fresh$6) = fresh$6 match { case c => e }
                |  def isDefinedAt(fresh$6) = fresh$6 match { case c => true case _ => false } }).map(new { this =>
                |    def apply(fresh$7) = fresh$7 match { case c => f }
                |    def isDefinedAt(fresh$7) = fresh$7 match { case c => true case _ => false }
                |}) }""".stripMargin)
      // Example from the spec
      val src = """object a {
                  |  for  { i <- 1 until n
                  |         j <- 1 until i
                  |         if isPrime(i+j)
                  |  } yield (i, j)
                  |}""".stripMargin
      val out = """object a { 1.until(n).flatMap(new { this =>
                  |  def apply(fresh$8) = fresh$8 match { case i => 1.until(i).withFilter(new { this =>
                  |    def apply(fresh$9) = fresh$9 match { case j => isPrime(i.+(j)) }
                  |    def isDefinedAt(fresh$9) = fresh$9 match { case j => true case _ => false } }).map(new { this =>
                  |    def apply(fresh$10) = fresh$10 match { case j => (i, j) }
                  |    def isDefinedAt(fresh$10) = fresh$10 match { case j => true case _ => false } }) }
                  |  def isDefinedAt(fresh$8) = fresh$8 match { case i => true case _ => false }
                  |}) }""".stripMargin
      runTest(src, out)
    }

    test("for comprehension refutable") {
      runTest("object a { val b = for ((c, 0) <- d) yield e }",
              """object a { val b = d.withFilter(new { this =>
                |  def apply(fresh$11) = fresh$11 match { case (c, 0) => true case _ => false }
                |  def isDefinedAt(fresh$11) = fresh$11 match { case (c, 0) => true case _ => true case _ => false } }).map(new { this =>
                |    def apply(fresh$12) = fresh$12 match { case (c, 0) => e }
                |    def isDefinedAt(fresh$12) = fresh$12 match { case (c, 0) => true case _ => false }
                |}) }""".stripMargin)
    }

    test("for comprehension value") {
      // This test is a hack, depending on the names "fresh$1" and "fresh$2" generated by Term.fresh()
      runTest("object a { val b = for (c <- d; e = f) yield g}",
              """object a { val b = d.map(new { this =>
                |  def apply(fresh$15) = fresh$15 match { case fresh$13 @ c => f match { case fresh$14 @ e => (fresh$13, fresh$14) } }
                |  def isDefinedAt(fresh$15) = fresh$15 match { case fresh$13 @ c => true case _ => false } }).map(new { this =>
                |    def apply(fresh$16) = fresh$16 match { case (c, e) => g }
                |    def isDefinedAt(fresh$16) = fresh$16 match { case (c, e) => true case _ => false }
                |}) }""".stripMargin)
    }

    test("partial function") {
      runTest("object a { val b = { case c => d; case (e, f) => g } }",
              """object a { val b = new { this =>
                |  def apply(fresh$17) = fresh$17 match { case c => d case (e, f) => g }
                |  def isDefinedAt(fresh$17) = fresh$17 match { case c => true case (e, f) => true case _ => false }
                |} }""".stripMargin)
    }

    test("val pattern") {
      runTest("object a { val b = { val _ = 1; val () = (); val (c, d) = e; val F(G, h @ I()) = j; k } }",
              """object a {
                |  val b = { 1 match {
                |    case _ => () match {
                |      case () => e match {
                |        case (c, d) => j match {
                |          case F(G, h @ I()) => k
                |        }
                |      }
                |    }
                |  } }
                |}""".stripMargin)
    }
  }
}